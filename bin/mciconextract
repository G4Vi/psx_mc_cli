#!/usr/bin/perl

use strict; use warnings;
use feature 'say';
use Encode qw(decode);
use FindBin;
use lib "$FindBin::Bin/../lib";
use PSX::MC;

sub extract_icon {
	my($save) = @_;
    my $fileheader = $save->{'header'};
	my $contents = $save->{'data'};

	if($fileheader->{'framecnt'} == 0) {
		warn("Save is invalid, bad icon framecnt read, assuming 1");
		$fileheader->{'framecnt'} = 1;
	}
	my $framedata = substr($contents, 0x80, 0x80*$fileheader->{'framecnt'});

	my $timbuf = '' .
	pack('V', 0x10) .                                     # magic
	pack('V', 0x8)  .                                     # flags, hasclut and (flags & 3) == 0 (4bit clut)
	pack('V', 12+(16*2)) .                                # clut len including header
	pack('vvvv', 0, 0, 16, 1) .                           # clut pos and dimensions
	pack('v16', @{$fileheader->{'clut'}}) .               # actual clut
	pack('V', 12+(0x80 * $fileheader->{'framecnt'})) .    # image len including header
	pack('vvvv', 1, 0, 4, 16*$fileheader->{'framecnt'}) . # image pos and dimensions
	pack('a*', $framedata);	                              # actual image
    print $timbuf;
}

@ARGV >= 1 or die('not enough args provided');

my $file = $ARGV[0];
my $mcfile = PSX::MC->load($file);
if(! $mcfile) {
	die("unable to load: $file");
}

my $searchfname;
$searchfname = decode('utf8', $ARGV[1]) if (@ARGV >= 2);
my @saves;
# find a valid save
if($mcfile->{'type'} eq 'mcd') {
	$mcfile->foreachDirEntry(sub {
		my ($entry, $newsave, $entrydata) = @_;			
        if($newsave && PSX::MC::SaveNameAndTitleMatch($newsave, $searchfname)) {
			push @saves, $newsave;
			return;
		}
	});	
}
elsif($mcfile->{'type'} eq 'mcs') {
	my $save = $mcfile->readSave();
	push @saves, $save;
}
else {
	die("unhandled format");
}

my $save = shift @saves;
$save or die("no save found to extract icon");
$save->{'header'} = PSX::MC::parse_file_header($save->{'data'});
extract_icon($save);

