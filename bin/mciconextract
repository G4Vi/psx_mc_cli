#!/usr/bin/perl

use strict; use warnings;
use feature 'say';

use Encode qw(decode encode);

sub is_mcd {
	my ($res) = @_;
	# A PSX memory card is 1 Mebibyte/ 128 kibibyte/ 131072 bytes
	# 1 header block of 8192 and 15 data blocks of 8192.
	return (length($res) == 131072);
}

sub is_mcs {
	my ($res) = @_;
	# A PSX mcs save is 1 directory frame and X data frames
	my $datasize = length($res) - 0x80;
	(($datasize % 0x2000) == 0) or return 0;

	return 1;
}

sub parse_directory {
	my ($directory) = @_;
	my $inuse = unpack('C', $directory);
	my $datasize = unpack('V', substr($directory, 0x4, 0x4));
	my $linkindex = unpack('v', substr($directory, 0x8));
	my $codestr =  unpack('Z*', substr($directory, 0xA));
	my @toxor    = unpack('C127', $directory);
	my $storedxor = unpack('C', substr($directory, 0x7F));

	#my @blocktypes = ('INUSE', 'SRTLINK', 'MIDLINK', 'ENDLINK', 'EMPTY', 'UNUSABLE', 'UNKNOWN');
	my $blockcount = int($datasize / 0x2000);

	my $calcxor = 0;
	foreach my $char (@toxor) {
        $calcxor ^= $char; 
    }

	return {
		'inuse'     => $inuse,
		'datasize'  => $datasize,
		'linkindex' => $linkindex,
		'codename'  => $codestr,
		'xor'       => $storedxor,

		'calcxor'    => $calcxor,
		'calcblocks' => $blockcount
	};
}


sub parse_file_header {
	my ($file) = @_;
	my $id = unpack('a2', $file);
	my $displayflag = unpack('C', substr($file, 0x2));
    my $blocknum = unpack('C', substr($file, 0x3));
	my $shiftjisbuf = unpack('a64', substr($file, 0x4, 0x40));
	my @clut = unpack('v16', substr($file, 0x60, 0x20));


	my $iconfnt = 0;
    if(($displayflag >= 0x11)|| ($displayflag <= 0x13)) {
		$iconfnt = $displayflag - 0x10;
	}

	my $firstnul = index($shiftjisbuf, "\0");
	if($firstnul != -1) {	
		$shiftjisbuf = substr($shiftjisbuf, 0, $firstnul);	
	}
	my $shiftjis = decode('shiftjis', $shiftjisbuf);

	return {
		'id' => $id,
		'displayflag' => $displayflag,
		'blocknum' => $blocknum,
		'titlebuf' =>  $shiftjisbuf,
		'clut' => \@clut,
		'title' => $shiftjis,
		'framecnt' => $iconfnt
	};
}

sub extract_icon {
	my($contents, $dataoffset) = @_;
	my $filebuf = substr($contents, $dataoffset, 0x80);
	my $fileheader = parse_file_header($filebuf);

	if($fileheader->{'framecnt'} == 0) {
		warn("Save is invalid, bad icon framecnt read, assuming 1");
		$fileheader->{'framecnt'} = 1;
	}
	my $framedata = substr($contents, $dataoffset+0x80, 0x80*$fileheader->{'framecnt'});

	my $timbuf = '' .
	pack('V', 0x10) .                                     # magic
	pack('V', 0x8)  .                                     # flags, hasclut and (flags & 3) == 0 (4bit clut)
	pack('V', 12+(16*2)) .                                # clut len including header
	pack('vvvv', 0, 0, 16, 1) .                           # clut pos and dimensions
	pack('v16', @{$fileheader->{'clut'}}) .               # actual clut
	pack('V', 12+(0x80 * $fileheader->{'framecnt'})) .    # image len including header
	pack('vvvv', 1, 0, 4, 16*$fileheader->{'framecnt'}) . # image pos and dimensions
	pack('a*', $framedata);	                              # actual image
    print $timbuf;
}

@ARGV >= 1 or die('not enough args provided');

my $file = $ARGV[0];
open(my $fh, '<', $file) or die("failed to open: $file");
my $contents;
my $res = read($fh, $contents, 131073);
(defined($res) && ($res <= 131072)) or die("input file wrong size");
my $ismcd = is_mcd($contents);
my $ismcs = is_mcs($contents);	

if($ismcd) {
	my $dataoffset = 0x2000;
	for(my $directoryoffset = 128; $directoryoffset < 2048;) {
		my $directory = substr($contents, $directoryoffset, 0x80);
		my $dir = parse_directory($directory);
		my $incblocks = 1;
		if($dir->{'calcblocks'}) {
			extract_icon($contents, $dataoffset);
			exit 0;
			$incblocks = $dir->{'calcblocks'};
		}
		$directoryoffset += ($incblocks * 128);
	    $dataoffset += ($incblocks * 0x2000);
	}
	die("Didn't find a valid save");			
}
elsif($ismcs) {
	extract_icon($contents, 0x80);
    exit 0;
}
else {
	die("Invalid input format");
}

