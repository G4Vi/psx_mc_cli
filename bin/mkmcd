#!/usr/bin/perl

# Copyright (c) 2021 Gavin Hayes and others, see LICENSE in the root of the project

use strict; use warnings;
use FindBin;
use File::Spec;
use lib "$FindBin::Bin/../lib";
use PSX::MC;

my @parentdir = ($FindBin::Bin, '..');
my @resdir = (@parentdir, 'res');

# create the memcard buf
my $blankfile = File::Spec->catfile(@resdir, 'blank.mcd');
open(my $tmpl, '<', $blankfile) or die("failed to open template");
my $memcard;
my $tmplres = read($tmpl, $memcard, 131073);
($tmplres && ($tmplres == 131072)) or die("template wrong size");

# Add each save to the memcard
my $directoryoffset = 0x80;
my $savedataoffset = 0x2000;
foreach my $file (@ARGV) {
    # load input file
    my $mcfile = PSX::MC->load($file);
	if(! $mcfile) {
		die("unable to load: $file");
	}
	my @saves;
	if($mcfile->{'type'} eq 'mcd') {
		$mcfile->foreachDirEntry(sub {
			my ($entry, $newsave, $entrydata) = @_;
			if($newsave) {
				push @saves, $newsave;
			}			
		});
	}	
	elsif($mcfile->{'type'} eq 'mcs') {
		push @saves, $mcfile->readSave();
	}
	else {
		die("unsupported filetype");
	}

	foreach my $save (@saves) {
		# create the mcd data from the save
	    my $mcdsave = PSX::MC::FormatSaveAsMCD($directoryoffset, $save);
    
	    # verify there is enough space for the save
        my $newdirspaceneeded = length($mcdsave->{'dirdata'});
	    my $newsavespaceneeded = length($mcdsave->{'savedata'});    
	    if(($newdirspaceneeded + $directoryoffset) > 2048) {
	    	die("Too many directory entries");
	    }
	    if(($newsavespaceneeded + $savedataoffset) > 131072) {
	    	die("Too much savedata");
	    }
    
        # copy in the save
        substr($memcard, $directoryoffset, $newdirspaceneeded, $mcdsave->{'dirdata'});
        substr($memcard, $savedataoffset, $newsavespaceneeded, $mcdsave->{'savedata'});
	    $directoryoffset += $newdirspaceneeded;
	    $savedataoffset += $newsavespaceneeded;
	}	
}

# output the memory card
print $memcard;